#include <avr/io.h>			// include I/O definitions (port names, pin names, etc)
#include <avr/interrupt.h>	// include interrupt support

#include "global.h"		// include our global settings
#include "uart.h"		// include uart function library
#include "rprintf.h"	// include printf function library
#include "timer.h"		// include timer function library (timing, PWM, etc)

// from https://raw.githubusercontent.com/adafruit/Adafruit_NeoPixel/master/Adafruit_NeoPixel.cpp
void neoLEDS(uint8_t *pixels, int numBytes) {
//	noInterrupts(); // Need 100% focus on instruction timing
	cli();

	volatile uint8_t *port = &PORTB;
	int pinMask = 1;

	

	volatile uint16_t
		i   = numBytes; // Loop counter
	volatile uint8_t
		*ptr = pixels,   // Pointer to next byte
		b   = *ptr++,   // Current byte value
		hi,             // PORT w/output bit set high
		lo;             // PORT w/output bit set low
	
	volatile uint8_t n1, n2 = 0;  // First, next bits out

    if(port == &PORTB) {
      hi = PORTB |  pinMask;
      lo = PORTB & ~pinMask;
      n1 = lo;
      if(b & 0x80) n1 = hi;

      asm volatile(
       "headB:"                   "\n\t"
        "out  %[port] , %[hi]"    "\n\t"
        "mov  %[n2]   , %[lo]"    "\n\t"
        "out  %[port] , %[n1]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "sbrc %[byte] , 6"        "\n\t"
         "mov %[n2]   , %[hi]"    "\n\t"
        "out  %[port] , %[lo]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "out  %[port] , %[hi]"    "\n\t"
        "mov  %[n1]   , %[lo]"    "\n\t"
        "out  %[port] , %[n2]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "sbrc %[byte] , 5"        "\n\t"
         "mov %[n1]   , %[hi]"    "\n\t"
        "out  %[port] , %[lo]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "out  %[port] , %[hi]"    "\n\t"
        "mov  %[n2]   , %[lo]"    "\n\t"
        "out  %[port] , %[n1]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "sbrc %[byte] , 4"        "\n\t"
         "mov %[n2]   , %[hi]"    "\n\t"
        "out  %[port] , %[lo]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "out  %[port] , %[hi]"    "\n\t"
        "mov  %[n1]   , %[lo]"    "\n\t"
        "out  %[port] , %[n2]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "sbrc %[byte] , 3"        "\n\t"
         "mov %[n1]   , %[hi]"    "\n\t"
        "out  %[port] , %[lo]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "out  %[port] , %[hi]"    "\n\t"
        "mov  %[n2]   , %[lo]"    "\n\t"
        "out  %[port] , %[n1]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "sbrc %[byte] , 2"        "\n\t"
         "mov %[n2]   , %[hi]"    "\n\t"
        "out  %[port] , %[lo]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "out  %[port] , %[hi]"    "\n\t"
        "mov  %[n1]   , %[lo]"    "\n\t"
        "out  %[port] , %[n2]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "sbrc %[byte] , 1"        "\n\t"
         "mov %[n1]   , %[hi]"    "\n\t"
        "out  %[port] , %[lo]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "out  %[port] , %[hi]"    "\n\t"
        "mov  %[n2]   , %[lo]"    "\n\t"
        "out  %[port] , %[n1]"    "\n\t"
        "rjmp .+0"                "\n\t"
        "sbrc %[byte] , 0"        "\n\t"
         "mov %[n2]   , %[hi]"    "\n\t"
        "out  %[port] , %[lo]"    "\n\t"
        "sbiw %[count], 1"        "\n\t"
        "out  %[port] , %[hi]"    "\n\t"
        "mov  %[n1]   , %[lo]"    "\n\t"
        "out  %[port] , %[n2]"    "\n\t"
        "ld   %[byte] , %a[ptr]+" "\n\t"
        "sbrc %[byte] , 7"        "\n\t"
         "mov %[n1]   , %[hi]"    "\n\t"
        "out  %[port] , %[lo]"    "\n\t"
        "brne headB"              "\n"
      : [byte] "+r" (b), [n1] "+r" (n1), [n2] "+r" (n2), [count] "+w" (i)
      : [port] "I" (_SFR_IO_ADDR(PORTB)), [ptr] "e" (ptr), [hi] "r" (hi),
        [lo] "r" (lo));
      
    }

	sei();
//	interrupts();
}
static	uint8_t blank[] = { // GRB
	0x00, 0x00, 0x00,
}; 

// 2x the output of hsv2rgb rainbow gocode output aim to have a smooth/endless rainbow
static	uint8_t pixels[] = { // GRB
0x00, 0x3f, 0x00,
0x04, 0x3f, 0x00,
0x09, 0x3f, 0x00,
0x0d, 0x3f, 0x00,
0x12, 0x3f, 0x00,
0x17, 0x3f, 0x00,
0x1b, 0x3f, 0x00,
0x20, 0x3f, 0x00,
0x25, 0x3f, 0x00,
0x29, 0x3f, 0x00,
0x2e, 0x3f, 0x00,
0x33, 0x3f, 0x00,
0x37, 0x3f, 0x00,
0x3c, 0x3f, 0x00,
0x3f, 0x3e, 0x00,
0x3f, 0x39, 0x00,
0x3f, 0x34, 0x00,
0x3f, 0x30, 0x00,
0x3f, 0x2b, 0x00,
0x3f, 0x26, 0x00,
0x3f, 0x22, 0x00,
0x3f, 0x1d, 0x00,
0x3f, 0x18, 0x00,
0x3f, 0x14, 0x00,
0x3f, 0x0f, 0x00,
0x3f, 0x0a, 0x00,
0x3f, 0x06, 0x00,
0x3f, 0x01, 0x00,
0x3f, 0x00, 0x03,
0x3f, 0x00, 0x07,
0x3f, 0x00, 0x0c,
0x3f, 0x00, 0x11,
0x3f, 0x00, 0x15,
0x3f, 0x00, 0x1a,
0x3f, 0x00, 0x1f,
0x3f, 0x00, 0x23,
0x3f, 0x00, 0x28,
0x3f, 0x00, 0x2d,
0x3f, 0x00, 0x31,
0x3f, 0x00, 0x36,
0x3f, 0x00, 0x3b,
0x3f, 0x00, 0x3f,
0x3b, 0x00, 0x3f,
0x36, 0x00, 0x3f,
0x31, 0x00, 0x3f,
0x2d, 0x00, 0x3f,
0x28, 0x00, 0x3f,
0x23, 0x00, 0x3f,
0x1f, 0x00, 0x3f,
0x1a, 0x00, 0x3f,
0x15, 0x00, 0x3f,
0x11, 0x00, 0x3f,
0x0c, 0x00, 0x3f,
0x07, 0x00, 0x3f,
0x03, 0x00, 0x3f,
0x00, 0x01, 0x3f,
0x00, 0x06, 0x3f,
0x00, 0x0a, 0x3f,
0x00, 0x0f, 0x3f,
0x00, 0x14, 0x3f,
0x00, 0x18, 0x3f,
0x00, 0x1d, 0x3f,
0x00, 0x22, 0x3f,
0x00, 0x26, 0x3f,
0x00, 0x2b, 0x3f,
0x00, 0x30, 0x3f,
0x00, 0x34, 0x3f,
0x00, 0x39, 0x3f,
0x00, 0x3e, 0x3f,
0x00, 0x3f, 0x3c,
0x00, 0x3f, 0x37,
0x00, 0x3f, 0x33,
0x00, 0x3f, 0x2e,
0x00, 0x3f, 0x29,
0x00, 0x3f, 0x25,
0x00, 0x3f, 0x20,
0x00, 0x3f, 0x1b,
0x00, 0x3f, 0x17,
0x00, 0x3f, 0x12,
0x00, 0x3f, 0x0d,
0x00, 0x3f, 0x09,
0x00, 0x3f, 0x04,
0x00, 0x3f, 0x00,
0x00, 0x3f, 0x00,
0x04, 0x3f, 0x00,
0x09, 0x3f, 0x00,
0x0d, 0x3f, 0x00,
0x12, 0x3f, 0x00,
0x17, 0x3f, 0x00,
0x1b, 0x3f, 0x00,
0x20, 0x3f, 0x00,
0x25, 0x3f, 0x00,
0x29, 0x3f, 0x00,
0x2e, 0x3f, 0x00,
0x33, 0x3f, 0x00,
0x37, 0x3f, 0x00,
0x3c, 0x3f, 0x00,
0x3f, 0x3e, 0x00,
0x3f, 0x39, 0x00,
0x3f, 0x34, 0x00,
0x3f, 0x30, 0x00,
0x3f, 0x2b, 0x00,
0x3f, 0x26, 0x00,
0x3f, 0x22, 0x00,
0x3f, 0x1d, 0x00,
0x3f, 0x18, 0x00,
0x3f, 0x14, 0x00,
0x3f, 0x0f, 0x00,
0x3f, 0x0a, 0x00,
0x3f, 0x06, 0x00,
0x3f, 0x01, 0x00,
0x3f, 0x00, 0x03,
0x3f, 0x00, 0x07,
0x3f, 0x00, 0x0c,
0x3f, 0x00, 0x11,
0x3f, 0x00, 0x15,
0x3f, 0x00, 0x1a,
0x3f, 0x00, 0x1f,
0x3f, 0x00, 0x23,
0x3f, 0x00, 0x28,
0x3f, 0x00, 0x2d,
0x3f, 0x00, 0x31,
0x3f, 0x00, 0x36,
0x3f, 0x00, 0x3b,
0x3f, 0x00, 0x3f,
0x3b, 0x00, 0x3f,
0x36, 0x00, 0x3f,
0x31, 0x00, 0x3f,
0x2d, 0x00, 0x3f,
0x28, 0x00, 0x3f,
0x23, 0x00, 0x3f,
0x1f, 0x00, 0x3f,
0x1a, 0x00, 0x3f,
0x15, 0x00, 0x3f,
0x11, 0x00, 0x3f,
0x0c, 0x00, 0x3f,
0x07, 0x00, 0x3f,
0x03, 0x00, 0x3f,
0x00, 0x01, 0x3f,
0x00, 0x06, 0x3f,
0x00, 0x0a, 0x3f,
0x00, 0x0f, 0x3f,
0x00, 0x14, 0x3f,
0x00, 0x18, 0x3f,
0x00, 0x1d, 0x3f,
0x00, 0x22, 0x3f,
0x00, 0x26, 0x3f,
0x00, 0x2b, 0x3f,
0x00, 0x30, 0x3f,
0x00, 0x34, 0x3f,
0x00, 0x39, 0x3f,
0x00, 0x3e, 0x3f,
0x00, 0x3f, 0x3c,
0x00, 0x3f, 0x37,
0x00, 0x3f, 0x33,
0x00, 0x3f, 0x2e,
0x00, 0x3f, 0x29,
0x00, 0x3f, 0x25,
0x00, 0x3f, 0x20,
0x00, 0x3f, 0x1b,
0x00, 0x3f, 0x17,
0x00, 0x3f, 0x12,
0x00, 0x3f, 0x0d,
0x00, 0x3f, 0x09,
0x00, 0x3f, 0x04,
0x00, 0x3f, 0x00,
	};


int main(void)
{
	// initialize our libraries
	// initialize the UART (serial port)
//	uartInit();
	// set the baud rate of the UART for our debug/reporting output
//	uartSetBaudRate(9600);
	// initialize the timer system
	timerInit();
	// initialize rprintf system
//	rprintfInit(uartSendByte);


	const int bytesPerPixels = 3;
	const int numBytes = sizeof(pixels);
	const int numPixels = numBytes/bytesPerPixels;

	
	DDRB |= 0x3f;
	PORTB &= ~0x01;
	timerPause(1);
	for(int i=0; i <  numPixels; i++) {
		neoLEDS(blank, sizeof(blank));
	}
	timerPause(1);

	

	char i=0;
	while (1) {
		neoLEDS(&pixels[i*bytesPerPixels], numBytes/2/2);
		if (0) {
			// to the cable
			i = (i+1) % (numPixels/2);
		} else {
			i = i-1;
			if (i < 0) {
				i = (numPixels/2)-1;
			}
		}
		
		timerPause(45);


#if BLANK
 		for(int i=0; i < numBytes/3 ; i++) {
			neo400KHz(blank, sizeof(blank));
		}
		timerPause(500);
#endif
	}
	
	return 0;
}
